<h1>Hello {name}!</h1>

<article>
		On <span class="ent">
			<span class="ent_text">
				<span class="ent">
					<span class="ent_text">January</span>
					<mark class="ent_label">month</mark>
				</span> 19th, 
				<span class="ent">
					<span class="ent_text">2038</span>
					<mark class="ent_label">year</mark>
				</span>
			</span>
			<mark class="ent_label">date</mark>
		</span> unix based operating systems will reach the same limit faced during the y2k scare.
</article>

<hr/>

<EntityText spans={calculateSpans(topics[topic].text, topics[topic][service])}></EntityText>

<script>
	import EntityText from './EntityText.html';

	export default {
		components: {
			EntityText
		},
		helpers: {
			calculateSpans(text, entities) {
				// get all the matches
				let allMatches = [];
				entities.forEach((ent)=> {allMatches = allMatches.concat(ent.matches)});
				// identify which matches overlap.
				let matchGroups = {};
				// sort the matches by length
				// (since it's not possible for smaller matches to include a larger one)
				allMatches.forEach((m)=>{m.length = m.end-m.start});
				allMatches.sort((m1, m2) =>(m2.length-m1.length));

				let entitySpans = {};
				allMatches.forEach((match) => {
					let positions = Object.keys(entitySpans);

					// find the span which ends after the match starts
					// and begins before the match ends.
					let overlapId = positions.findIndex((key) => {
						let span = entitySpans[key];
						return span.start <= match.end && span.end >= match.start;
					});
					if (overlapId >= 0) {
						console.log("==================");
						console.log("OVERLAP!");
						console.log(text.slice(match.start,match.end));
						let position = positions[overlapId];
						let span = entitySpans[position];
						console.log(text.slice(span.start,span.end));

						let matches = (span.matches || []);
						matches.push(match);
						span.matches = matches;
					} else {
						//console.log("==================");
						//console.log("No Overlap");
						entitySpans[match.start] = match;
					}
				});
				// Group matches heirarchically as needed.
				// Create a list of text chunks and match spans
				// to pass back
				let chunks = [];
				let lastPosition = 0;
				for (let position in entitySpans) {
					let span = entitySpans[position];
					lastPosition = (chunks.length > 0)? chunks[chunks.length-1].end : 0 ;
					if (lastPosition < span.start ) {
						let preamble = text.slice(lastPosition, span.start);
						chunks.push({ 
							type:"text", 
							text: preamble, 
							start: lastPosition, 
							end: span.start
						});
					}
					let entityText = text.slice(span.start, span.end)
					chunks.push({ 
						type:		"entity", 
						text: 	entityText, 
						start:	span.start, 
						end:		span.end, 
						entity: span
					});
				};
				let keys = Object.keys(entitySpans)
				let lastSpan = entitySpans[keys[keys.length-1]];
				if (lastSpan.end < text.length ){
					let lastChunk = {
						type: 'text',
						text: text.slice(lastSpan.end, text.length),
						start: lastSpan.end,
						end: text.length
					}
					chunks.push(lastChunk);
				}

				return chunks;
			}
		}
	};
</script>

<style>
	h1 {
		color: purple;
	}

	article {
		line-height: 3;
	}

	span.ent {
		display: inline-flex;
		flex-flow: column;
		border-left: 2px solid red;
		border-right: 2px solid red;
		line-height: normal;
	}

	span.ent_text > span.ent:first-child {
		border-left: none;
	}

	span.ent_text > span.ent:last-child {
		border-right: none;
	}

	mark.ent_label {
		background-color: red;
		color: white;
		text-transform: uppercase;
		font-size: small;
		font-family: Georgia, 'Times New Roman', Times, serif
	}
</style>